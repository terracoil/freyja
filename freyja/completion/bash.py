"""Bash shell completion handler."""

import os
import sys

from .base import CompletionContext, CompletionHandler


class BashCompletionHandler(CompletionHandler):
    """Bash-specific completion handler."""

    def generate_script(self, prog_name: str, command_patterns: list[str] | None = None) -> str:
        """Generate bash completion script with pattern-based registration for path invocations.

        :param prog_name: Base program name
        :param command_patterns: Additional command patterns to register completion for
        """
        from pathlib import Path

        # Always use basename for consistency - this fixes path-based invocation issues
        prog_basename = Path(prog_name).name
        func_name = prog_basename.replace("-", "_").replace(".", "_")

        script = f'''#!/bin/bash
# Bash completion for {prog_basename} and related command patterns
# Generated by freyja

_{func_name}_completion()
{{
    local cur prev opts
    COMPREPLY=()
    cur="${{COMP_WORDS[COMP_CWORD]}}"
    prev="${{COMP_WORDS[COMP_CWORD-1]}}"

    # Get the actual command being completed (first word)
    # Extract basename to handle path-based invocations (e.g., examples/{prog_basename})
    local prog="${{COMP_WORDS[0]}}"
    local prog_basename="$(basename "$prog")"

    # Get completions with inline env vars to prevent shell persistence
    local completions
    # Check if this looks like a Python script
    if [[ "$prog" == *.py ]] || [[ ! -x "$prog" ]] || \\
       [[ -f "$prog" && "$(head -n1 "$prog" 2>/dev/null)" == *"python"* ]]; then
        # For Python scripts, use python interpreter
        completions=$(
            _FREYJA_COMPLETE=bash \\
            COMP_WORDS_STR="${{COMP_WORDS[@]}}" \\
            COMP_CWORD_NUM=${{COMP_CWORD}} \\
            PYTHONPATH=. python "$prog" --_complete 2>/dev/null
        )
    else
        # For direct executables
        completions=$(
            _FREYJA_COMPLETE=bash \\
            COMP_WORDS_STR="${{COMP_WORDS[@]}}" \\
            COMP_CWORD_NUM=${{COMP_CWORD}} \\
            PYTHONPATH=. "$prog" --_complete 2>/dev/null
        )
    fi

    if [ $? -eq 0 ]; then
        COMPREPLY=($(compgen -W "${{completions}}" -- "${{cur}}"))
    fi

    return 0
}}

# Register completion for the base command name
complete -F _{func_name}_completion {prog_basename}

# Register completion for path-based invocations
# Handles: examples/{prog_basename}, ./bin/{prog_basename}, etc.
complete -F _{func_name}_completion "./{prog_basename}"
complete -F _{func_name}_completion "*/{prog_basename}"'''

        # Add registration for additional command patterns if provided
        if command_patterns:
            for pattern in command_patterns:
                pattern_basename = Path(pattern).name
                script += f"\n\n# Additional pattern: {pattern}"
                script += f"\ncomplete -F _{func_name}_completion {pattern_basename}"
                script += f'\ncomplete -F _{func_name}_completion "*/{pattern_basename}"'

        return script

    def get_completions(self, context: CompletionContext) -> list[str]:
        """Get bash-specific completions."""
        return self._get_generic_completions(context)

    def install_completion(self, prog_name: str) -> bool:
        """Install bash completion."""
        from .installer import CompletionInstaller

        installer = CompletionInstaller(self, prog_name)
        return installer.install("bash")


def handle_bash_completion() -> None:
    """Handle bash completion request from environment variables."""
    if os.environ.get("_FREYJA_COMPLETE") != "bash":
        return

    # Parse completion context from environment
    words_str = os.environ.get("COMP_WORDS_STR", "")
    cword_num = int(os.environ.get("COMP_CWORD_NUM", "0"))

    if not words_str:
        return

    words = words_str.split()
    if not words or cword_num >= len(words):
        return

    # Extract command group path (everything between program name and current word)
    command_group_path = []
    if len(words) > 1:
        for i in range(1, min(cword_num, len(words))):
            word = words[i]
            if not word.startswith("-"):
                command_group_path.append(word)

    # Import here to avoid circular imports

    # This would need to be set up by the FreyjaCLI instance
    # For now, just output basic completions
    print("--help --verbose --no-color")
    sys.exit(0)
