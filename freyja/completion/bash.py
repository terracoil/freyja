"""Bash shell completion handler."""

import os
import sys
from typing import List

from .base import CompletionContext, CompletionHandler


class BashCompletionHandler(CompletionHandler):
  """Bash-specific completion handler."""

  def generate_script(self, prog_name: str) -> str:
    """Generate bash completion script."""
    script = f'''#!/bin/bash
# Bash completion for {prog_name}
# Generated by freyja

_{prog_name}_completion()
{{
    local cur prev opts
    COMPREPLY=()
    cur="${{COMP_WORDS[COMP_CWORD]}}"
    prev="${{COMP_WORDS[COMP_CWORD-1]}}"

    # Set up completion environment
    export _FREYA_COMPLETE=bash
    export COMP_WORDS_STR="${{COMP_WORDS[@]}}"
    export COMP_CWORD_NUM=${{COMP_CWORD}}
    
    # Get completions from the program
    local completions
    completions=$({prog_name} --_complete 2>/dev/null)
    
    if [ $? -eq 0 ]; then
        COMPREPLY=($(compgen -W "${{completions}}" -- "${{cur}}"))
    fi

    return 0
}}

# Register completion function
complete -F _{prog_name}_completion {prog_name}
'''
    return script

  def get_completions(self, context: CompletionContext) -> List[str]:
    """Get bash-specific completions."""
    return self._get_generic_completions(context)

  def install_completion(self, prog_name: str) -> bool:
    """Install bash completion."""
    from .installer import CompletionInstaller
    installer = CompletionInstaller(self, prog_name)
    return installer.install('bash')

  def _get_generic_completions(self, context: CompletionContext) -> List[str]:
    """Get generic completions that work across shells."""
    completions = []

    # Get the appropriate parser for current context
    parser = context.parser
    if context.command_group_path:
      parser = self.get_command_group_parser(parser, context.command_group_path)
      if not parser:
        return []

    # Determine what we're completing
    current_word = context.current_word

    # Check if we're completing an option value
    if len(context.words) >= 2:
      prev_word = context.words[-2] if len(context.words) >= 2 else ""

      # If previous word is an option, complete its values
      if prev_word.startswith('--'):
        option_values = self.get_option_values(parser, prev_word, current_word)
        if option_values:
          return option_values

    # Complete options if current word starts with --
    if current_word.startswith('--'):
      options = self.get_available_options(parser)
      return self.complete_partial_word(options, current_word)

    # Complete cmd_tree/command groups
    commands = self.get_available_commands(parser)
    if commands:
      return self.complete_partial_word(commands, current_word)

    return completions


def handle_bash_completion() -> None:
  """Handle bash completion request from environment variables."""
  if os.environ.get('_FREYA_COMPLETE') != 'bash':
    return

  # Parse completion context from environment
  words_str = os.environ.get('COMP_WORDS_STR', '')
  cword_num = int(os.environ.get('COMP_CWORD_NUM', '0'))

  if not words_str:
    return

  words = words_str.split()
  if not words or cword_num >= len(words):
    return

  current_word = words[cword_num] if cword_num < len(words) else ""

  # Extract command group path (everything between program name and current word)
  command_group_path = []
  if len(words) > 1:
    for i in range(1, min(cword_num, len(words))):
      word = words[i]
      if not word.startswith('-'):
        command_group_path.append(word)

  # Import here to avoid circular imports

  # This would need to be set up by the FreyjaCLI instance
  # For now, just output basic completions
  print("--help --verbose --no-color")
  sys.exit(0)
