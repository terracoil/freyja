"""Zsh shell completion handler."""

import os
import sys
from typing import List

from .base import CompletionContext, CompletionHandler


class ZshCompletionHandler(CompletionHandler):
  """Zsh-specific completion handler."""

  def generate_script(self, prog_name: str, command_patterns: List[str] = None) -> str:
    """Generate zsh completion script.
    
    :param prog_name: Base program name
    :param command_patterns: Additional command patterns to register completion for
    """
    # Default patterns - just the base program name
    patterns = [prog_name]
    
    # Add additional patterns if provided
    if command_patterns:
      patterns.extend(command_patterns)
    
    # Create compdef line with patterns
    # Use -P flag for patterns that contain slashes (paths)
    compdef_parts = ['#compdef']
    
    for pattern in patterns:
      if '/' in pattern or pattern.startswith('./'):
        compdef_parts.append(f"-P '{pattern}'")
      else:
        compdef_parts.append(pattern)
    
    compdef_line = ' '.join(compdef_parts)
    
    # Use the first pattern as the function name base
    # For zsh completion files, function name MUST match filename (without the underscore)
    func_name = prog_name.replace('-', '_').replace('/', '_').replace('.', '_')
    
    script = f'''{compdef_line}
# Zsh completion for {prog_name} and related command patterns
# Generated by freyja

_{func_name}() {{
    # Set up completion environment variables
    export _FREYJA_COMPLETE=zsh
    export COMP_WORDS_STR="${{words[@]}}"
    export COMP_CWORD_NUM=${{#words[@]}}

    # Get the actual command being completed (first word)
    local prog="${{words[1]}}"
    
    # Call the program to get completions
    local -a completions
    # Check if file looks like a Python script by examining its content or extension
    local use_python=false
    if [[ "${{prog}}" == *.py ]] || [[ ! -x "${{prog}}" ]]; then
        use_python=true
    elif [[ -f "${{prog}}" ]]; then
        # Check if file starts with python shebang
        local first_line=$(head -n1 "${{prog}}" 2>/dev/null)
        if [[ "$first_line" == *"python"* ]]; then
            use_python=true
        fi
    fi
    
    if [[ "$use_python" == true ]]; then
        # For Python scripts, use python interpreter
        completions=($(PYTHONPATH=. python "${{prog}}" --_complete 2>/dev/null))
    else
        # For direct executables
        completions=($(PYTHONPATH=. "${{prog}}" --_complete 2>/dev/null))
    fi
    
    # Add completions if we got any
    if [[ $#completions -gt 0 ]]; then
        compadd -a completions
    fi
}}
'''
    return script

  def get_completions(self, context: CompletionContext) -> List[str]:
    """Get zsh-specific completions."""
    # Reuse bash completion logic for now
    from .bash import BashCompletionHandler
    bash_handler = BashCompletionHandler(self.cli)
    return bash_handler._get_generic_completions(context)

  def install_completion(self, prog_name: str) -> bool:
    """Install zsh completion."""
    from .installer import CompletionInstaller
    installer = CompletionInstaller(self, prog_name)
    return installer.install('zsh')


def handle_zsh_completion() -> None:
  """Handle zsh completion request from environment variables."""
  # This function should not be called anymore
  # Completion is handled through the ExecutionCoordinator._handle_completion_request
  # But for compatibility, if we somehow reach here, just exit cleanly
  sys.exit(0)
