#!/usr/bin/env bash
set -euo pipefail

# update-modgud - Update and clean the modgud submodule
#
# This script updates the modgud submodule to the latest version from its
# remote repository, then cleans development-related files that aren't needed
# for Freyja's runtime usage. Safe to run multiple times (idempotent).
#
# Usage:
#   bin/update-modgud [--dry-run] [--branch BRANCH] [--tag TAG] [--no-clean]
#
# Options:
#   --dry-run      Show what would be done without actually doing it
#   --branch BRANCH  Update to specific branch (default: master)
#   --tag TAG        Update to specific tag instead of branch
#   --no-clean       Skip cleanup step (only update)

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
NC='\033[0m' # No Color

# Script directory and project root
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_ROOT="$(cd "$SCRIPT_DIR/.." && pwd)"
SUBMODULE_PATH="$PROJECT_ROOT/freyja/utils/modgud"

# Default options
DRY_RUN=false
BRANCH="master"
TAG=""
NO_CLEAN=false

# Parse arguments
while [[ $# -gt 0 ]]; do
  case $1 in
    --dry-run)
      DRY_RUN=true
      shift
      ;;
    --branch)
      BRANCH="$2"
      shift 2
      ;;
    --tag)
      TAG="$2"
      shift 2
      ;;
    --no-clean)
      NO_CLEAN=true
      shift
      ;;
    *)
      echo -e "${RED}โ Error: Unknown option: $1${NC}" >&2
      echo "Usage: bin/update-modgud [--dry-run] [--branch BRANCH] [--tag TAG] [--no-clean]" >&2
      exit 1
      ;;
  esac
done

# Validate conflicting options
if [[ -n "$TAG" ]] && [[ "$BRANCH" != "master" ]]; then
  echo -e "${RED}โ Error: Cannot specify both --branch and --tag${NC}" >&2
  exit 1
fi

# Dry run indicator
if [[ "$DRY_RUN" == true ]]; then
  echo -e "${YELLOW}๐ DRY RUN MODE - No changes will be made${NC}"
  echo
fi

# Verify submodule exists
if [[ ! -d "$SUBMODULE_PATH" ]]; then
  echo -e "${RED}โ Error: modgud submodule not found at $SUBMODULE_PATH${NC}" >&2
  echo -e "${CYAN}๐ก Initialize with: git submodule update --init --recursive${NC}" >&2
  exit 1
fi

# Verify it's a git repository
if [[ ! -d "$SUBMODULE_PATH/.git" ]] && [[ ! -f "$SUBMODULE_PATH/.git" ]]; then
  echo -e "${RED}โ Error: $SUBMODULE_PATH is not a git repository${NC}" >&2
  exit 1
fi

echo -e "${BLUE}โโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโ${NC}"
echo -e "${BLUE}๐ฆ Updating modgud submodule${NC}"
echo -e "${BLUE}โโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโ${NC}"
echo -e "${BLUE}๐ Location: $SUBMODULE_PATH${NC}"
echo

# Get current commit before update
CURRENT_COMMIT=$(cd "$SUBMODULE_PATH" && git rev-parse --short HEAD)
echo -e "${CYAN}๐ Current commit: $CURRENT_COMMIT${NC}"

# Update submodule
echo
echo -e "${BLUE}๐ Fetching latest changes...${NC}"
if [[ "$DRY_RUN" == true ]]; then
  echo -e "${YELLOW}  [DRY RUN] Would run: git fetch --all --tags${NC}"
else
  cd "$SUBMODULE_PATH"
  if ! git fetch --all --tags 2>&1 | sed 's/^/  /'; then
    echo -e "${RED}โ Error: Failed to fetch from remote${NC}" >&2
    exit 1
  fi
fi

# Checkout target version
echo
if [[ -n "$TAG" ]]; then
  echo -e "${BLUE}๐ท๏ธ  Checking out tag: $TAG${NC}"
  if [[ "$DRY_RUN" == true ]]; then
    echo -e "${YELLOW}  [DRY RUN] Would run: git checkout tags/$TAG${NC}"
  else
    cd "$SUBMODULE_PATH"
    if ! git checkout "tags/$TAG" 2>&1 | sed 's/^/  /'; then
      echo -e "${RED}โ Error: Failed to checkout tag $TAG${NC}" >&2
      exit 1
    fi
  fi
else
  echo -e "${BLUE}๐ฟ Updating branch: $BRANCH${NC}"
  if [[ "$DRY_RUN" == true ]]; then
    echo -e "${YELLOW}  [DRY RUN] Would run: git checkout $BRANCH && git pull origin $BRANCH${NC}"
  else
    cd "$SUBMODULE_PATH"
    if ! git checkout "$BRANCH" 2>&1 | sed 's/^/  /'; then
      echo -e "${RED}โ Error: Failed to checkout branch $BRANCH${NC}" >&2
      exit 1
    fi
    if ! git pull origin "$BRANCH" 2>&1 | sed 's/^/  /'; then
      echo -e "${RED}โ Error: Failed to pull from origin/$BRANCH${NC}" >&2
      exit 1
    fi
  fi
fi

# Show new commit
echo
NEW_COMMIT=$(cd "$SUBMODULE_PATH" && git rev-parse --short HEAD)
if [[ "$CURRENT_COMMIT" == "$NEW_COMMIT" ]]; then
  echo -e "${GREEN}โ Already up to date at commit: $NEW_COMMIT${NC}"
else
  echo -e "${GREEN}โ Updated from $CURRENT_COMMIT to $NEW_COMMIT${NC}"

  # Show what changed
  cd "$SUBMODULE_PATH"
  echo
  echo -e "${CYAN}๐ Changes:${NC}"
  git log --oneline "$CURRENT_COMMIT..$NEW_COMMIT" | sed 's/^/  /' || true
fi

# Update parent repo's submodule reference
if [[ "$DRY_RUN" == false ]] && [[ "$CURRENT_COMMIT" != "$NEW_COMMIT" ]]; then
  echo
  echo -e "${BLUE}๐ Updating parent repository submodule reference...${NC}"
  cd "$PROJECT_ROOT"
  git add "$SUBMODULE_PATH"
  echo -e "${GREEN}  โ Submodule reference updated (remember to commit)${NC}"
fi

# Cleanup phase
if [[ "$NO_CLEAN" == true ]]; then
  echo
  echo -e "${CYAN}โญ๏ธ  Skipping cleanup (--no-clean specified)${NC}"
else
  echo
  echo -e "${BLUE}โโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโ${NC}"
  echo -e "${BLUE}๐งน Cleaning development files${NC}"
  echo -e "${BLUE}โโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโ${NC}"
  echo

  # Items to remove - directories and file patterns
  DIRS_TO_REMOVE=(
    ".venv"
    "tests"
    "docs"
    "bin"
    "tmp"
    "dist"
    "build"
    ".pytest_cache"
    ".mypy_cache"
    ".ruff_cache"
    "__pycache__"
  )

  FILES_TO_REMOVE=(
    "*.md"
    "*.toml"
    "*.txt"
    ".gitignore"
    ".pre-commit-config.yaml"
  )

  # Track what was removed
  removed_count=0
  skipped_count=0

  # Function to remove directory
  remove_dir() {
    local dir_path="$1"
    local dir_name="$(basename "$dir_path")"

    if [[ -d "$dir_path" ]]; then
      if [[ "$DRY_RUN" == true ]]; then
        echo -e "${YELLOW}  [DRY RUN] Would remove directory: $dir_name${NC}"
        removed_count=$((removed_count + 1))
      else
        rm -rf "$dir_path"
        echo -e "${GREEN}  โ Removed directory: $dir_name${NC}"
        removed_count=$((removed_count + 1))
      fi
    else
      skipped_count=$((skipped_count + 1))
    fi
  }

  # Function to remove files matching pattern
  remove_files() {
    local pattern="$1"
    local found_files

    # Use nullglob to handle no matches gracefully
    shopt -s nullglob
    found_files=("$SUBMODULE_PATH"/$pattern)
    shopt -u nullglob

    if [[ ${#found_files[@]} -gt 0 ]]; then
      for file in "${found_files[@]}"; do
        local filename="$(basename "$file")"

        if [[ "$DRY_RUN" == true ]]; then
          echo -e "${YELLOW}  [DRY RUN] Would remove file: $filename${NC}"
          removed_count=$((removed_count + 1))
        else
          rm -f "$file"
          echo -e "${GREEN}  โ Removed file: $filename${NC}"
          removed_count=$((removed_count + 1))
        fi
      done
    fi
  }

  # Remove directories
  echo -e "${BLUE}๐ Removing directories...${NC}"
  for dir in "${DIRS_TO_REMOVE[@]}"; do
    remove_dir "$SUBMODULE_PATH/$dir"
  done

  echo
  echo -e "${BLUE}๐ Removing files...${NC}"
  # Remove files matching patterns
  for pattern in "${FILES_TO_REMOVE[@]}"; do
    remove_files "$pattern"
  done

  # Cleanup summary
  echo
  echo -e "${BLUE}โโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโ${NC}"
  if [[ "$DRY_RUN" == true ]]; then
    echo -e "${YELLOW}๐ CLEANUP DRY RUN COMPLETE${NC}"
    echo -e "${YELLOW}   Would remove: $removed_count items${NC}"
  else
    echo -e "${GREEN}โ CLEANUP COMPLETE${NC}"
    echo -e "${GREEN}   Removed: $removed_count items${NC}"
  fi
  echo -e "${BLUE}   Skipped: $skipped_count items (already absent)${NC}"
  echo -e "${BLUE}โโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโ${NC}"

  # Verify essential files remain
  echo
  echo -e "${BLUE}๐ Verifying essential files remain...${NC}"
  essential_ok=true

  if [[ -d "$SUBMODULE_PATH/modgud" ]]; then
    echo -e "${GREEN}  โ modgud/ package directory present${NC}"
  else
    echo -e "${RED}  โ modgud/ package directory MISSING${NC}"
    essential_ok=false
  fi

  if [[ -f "$SUBMODULE_PATH/LICENSE" ]]; then
    echo -e "${GREEN}  โ LICENSE file present${NC}"
  else
    echo -e "${YELLOW}  โ LICENSE file missing (optional)${NC}"
  fi

  if [[ -d "$SUBMODULE_PATH/.git" ]] || [[ -f "$SUBMODULE_PATH/.git" ]]; then
    echo -e "${GREEN}  โ Git submodule metadata present${NC}"
  else
    echo -e "${RED}  โ Git submodule metadata MISSING${NC}"
    essential_ok=false
  fi

  if [[ "$essential_ok" == false ]]; then
    echo
    echo -e "${RED}โ ERROR: Essential files are missing after cleanup!${NC}" >&2
    exit 1
  fi
fi

# Final summary
echo
echo -e "${BLUE}โโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโ${NC}"
if [[ "$DRY_RUN" == true ]]; then
  echo -e "${YELLOW}โน๏ธ  Run without --dry-run to actually apply changes${NC}"
else
  echo -e "${GREEN}โจ modgud submodule updated successfully!${NC}"
  if [[ "$CURRENT_COMMIT" != "$NEW_COMMIT" ]]; then
    echo -e "${CYAN}๐ก Don't forget to commit the submodule reference update:${NC}"
    echo -e "${CYAN}   git commit -m 'Update modgud submodule to $NEW_COMMIT'${NC}"
  fi
fi
echo -e "${BLUE}โโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโ${NC}"

exit 0
