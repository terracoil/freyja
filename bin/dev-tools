#!/usr/bin/env python3
"""
Freyja Development Tools CLI
Consolidates all development scripts into a single FreyjaCLI implementation.
"""
import glob
import os
import shutil
import subprocess
import sys
from pathlib import Path
from typing import Optional

# Add the project root to the Python path
project_root = Path(__file__).parent.parent
sys.path.insert(0, str(project_root))

from freyja import FreyjaCLI


class FreyjaDevTools:
  """
  Freyja Development Tools - Comprehensive development utilities.
  
  A complete development toolkit using Freyja's inner class pattern to organize
  build, test, and development setup commands.
  """

  def __init__(self, verbose: bool = False, dry_run: bool = False):
    """
    Initialize development tools.
    
    :param verbose: Enable verbose output for all operations
    :param dry_run: Show commands that would be run without executing them
    """
    self.verbose = verbose
    self.dry_run = dry_run
    self.project_root = project_root
    self.colors = {
      'red': '\033[0;31m',
      'green': '\033[0;32m',
      'yellow': '\033[1;33m',
      'blue': '\033[0;34m',
      'nc': '\033[0m'  # No Color
    }

  def _clean(self) -> None:
    """Clean build artifacts, cache files, and temporary files."""
    self._print_info("🧹 Cleaning build artifacts and cache files...")

    # Patterns to clean
    patterns_to_remove = [
      "**/*.pyc",
      "**/__pycache__",
      "**/.ipynb_checkpoints",
      "**/.pytest_cache",
      "build",
      "dist",
      "*.egg-info"
    ]

    removed_count = 0
    for pattern in patterns_to_remove:
      for path in glob.glob(pattern, recursive=True):
        path_obj = Path(path)
        try:
          if path_obj.is_dir():
            if not self.dry_run:
              shutil.rmtree(path_obj)
            if self.verbose or self.dry_run:
              print(f"Removed directory: {path}")
            removed_count += 1
          elif path_obj.is_file():
            if not self.dry_run:
              path_obj.unlink()
            if self.verbose or self.dry_run:
              print(f"Removed file: {path}")
            removed_count += 1
        except Exception as e:
          self._print_error(f"Failed to remove {path}: {e}")

    if removed_count > 0:
      self._print_success(f"Cleaned {removed_count} items")
    else:
      self._print_info("No items to clean")

  def _run_command(self, command: str, description: str = "", shell: bool = True, check: bool = True) -> bool:
    """
    Execute a shell command with proper logging.

    :param command: Command to execute
    :param description: Description of the command for output
    :param shell: Whether to run in shell mode
    :param check: Whether to raise exception on non-zero exit code
    :return: True if command succeeded, False otherwise
    """
    if description:
      print(f"{self.colors['blue']}{description}{self.colors['nc']}")

    if self.verbose or self.dry_run:
      print(f"Command: {command}")

    if self.dry_run:
      print("(DRY RUN - command not executed)")
      return True

    try:
      result = subprocess.run(command, shell=shell, check=check, cwd=self.project_root)
      return result.returncode == 0
    except subprocess.CalledProcessError as e:
      print(f"{self.colors['red']}❌ Command failed with exit code {e.returncode}{self.colors['nc']}")
      return False

  def _print_success(self, message: str) -> None:
    """Print success message with formatting."""
    print(f"{self.colors['green']}✅ {message}{self.colors['nc']}")

  def _print_error(self, message: str) -> None:
    """Print error message with formatting."""
    print(f"{self.colors['red']}❌ {message}{self.colors['nc']}")

  def _print_info(self, message: str) -> None:
    """Print info message with formatting."""
    print(f"{self.colors['blue']}ℹ️  {message}{self.colors['nc']}")

  class Setup:
    """Development environment and self-installation setup operations."""

    def __init__(self, parent):
      """Initialize setup operations.
      
      :param parent: Parent FreyjaDevTools instance
      """
      self.parent = parent

    def env(self) -> None:
      """Set up the development environment with dependencies and pre-commit hooks."""
      parent = self.parent
      print(f"{parent.colors['blue']}🚀 Setting up development environment for freyja...{parent.colors['nc']}")

      # Install dependencies
      if not parent._run_command("poetry install --with dev", "📦 Installing dependencies with Poetry..."):
        parent._print_error("Failed to install dependencies")
        return

      # Install pre-commit hooks
      if not parent._run_command("poetry run pre-commit install", "🪝 Installing pre-commit hooks..."):
        parent._print_error("Failed to install pre-commit hooks")
        return

      # Verify Python version
      parent._run_command("poetry run python --version", "🐍 Python version:")

      parent._print_success("Development environment setup complete!")
      print()
      print("Available commands:")
      print("  python bin/dev-tools build--compile     # Compile/build package")
      print("  python bin/dev-tools build--lint        # Run linters")
      print("  python bin/dev-tools test--run          # Run tests")
      print("  python bin/dev-tools build--publish     # Publish to PyPI")

    def self(self, force: bool = False) -> None:
      """
      Compile and install the latest freyja version from dist/.
      
      :param force: Force reinstallation even if version hasn't changed
      """
      parent = self.parent
      parent._print_info("🔧 Building and installing latest freyja version...")

      # First, build the package
      parent._print_info("Building package first...")
      if not parent._run_command("poetry build", "🔨 Building package..."):
        parent._print_error("Build failed!")
        return

      # Find the latest wheel file
      dist_dir = parent.project_root / "dist"
      if not dist_dir.exists():
        parent._print_error("dist/ directory not found. Run build first.")
        return

      wheel_files = list(dist_dir.glob("*.whl"))
      if not wheel_files:
        parent._print_error("No wheel files found in dist/. Build may have failed.")
        return

      # Get the latest wheel file (by modification time)
      latest_wheel = max(wheel_files, key=lambda p: p.stat().st_mtime)
      parent._print_info(f"Installing wheel: {latest_wheel.name}")

      # Install the wheel
      install_cmd = f"pip install {latest_wheel}"
      if force:
        install_cmd += " --force-reinstall"

      if not parent._run_command(install_cmd, f"📦 Installing {latest_wheel.name}..."):
        parent._print_error("Installation failed!")
        return

      # Verify installation
      parent._run_command(
        "python -c 'import freyja; print(f\"Freyja version: {freyja.__version__ if hasattr(freyja, \"__version__\") else \"unknown\"}\"); print(f\"Freyja location: {freyja.__file__}\")'",
        "🔍 Verifying installation:")

      parent._print_success("Self-installation complete!")
      parent._print_info("You can now use 'freyja' from anywhere on your system")

  class Quality:
    """Code quality, linting, and cleaning operations."""

    def __init__(self, parent):
      """
      Initialize quality operations.

      :param parent: Parent FreyjaDevTools instance
      """
      self.parent = parent

    def clean(self) -> None:
      """Clean build artifacts, cache files, and temporary files."""
      self.parent._clean()

    def lint(self, fix: bool = False) -> None:
      """
      Run all linting and formatting tools.

      :param fix: Automatically fix issues where possible
      """
      parent = self.parent
      parent._print_info("🔍 Running code quality checks...")

      success = True

      # Run Ruff
      ruff_cmd = "poetry run ruff check ."
      if fix:
        ruff_cmd += " --fix"
      if not parent._run_command(ruff_cmd, "📝 Running Ruff...", check=False):
        success = False

      # Run Black
      black_cmd = "poetry run black ."
      if not fix:
        black_cmd += " --check"
      if not parent._run_command(black_cmd, "⚫ Running Black...", check=False):
        success = False

      # Run MyPy
      if not parent._run_command("poetry run mypy freyja --ignore-missing-imports", "🔧 Running MyPy...", check=False):
        success = False

      # Run Pylint
      if not parent._run_command("poetry run pylint freyja", "🐍 Running Pylint...", check=False):
        success = False

      if success:
        parent._print_success("All code quality checks passed!")
      else:
        parent._print_error("Some code quality checks failed!")

  class Build:
    """Build, compilation, and publishing operations."""

    def __init__(self, parent, clean: bool = False, parallel: bool = True):
      """
      Initialize build operations.

      :param parent: Parent FreyjaDevTools instance
      :param clean: Clean build artifacts before operations
      :param parallel: Enable parallel execution where possible
      """
      self.parent = parent
      self.clean = clean
      self.parallel = parallel

    def compile(self) -> None:
      """Compile/build the package using Poetry."""
      parent = self.parent

      if self.clean:
        parent._clean()

      parent._print_info("🔨 Building package with Poetry...")

      if not parent._run_command("poetry build", "Building package..."):
        parent._print_error("Build failed!")
        return

      # Show build info
      parent._run_command("ls -la dist/", "📋 Build information:")
      parent._print_success("Package built successfully!")

    def publish(self, test_pypi: bool = False) -> None:
      """
      Build and publish package to PyPI.

      :param test_pypi: Publish to test PyPI instead of production
      """
      parent = self.parent
      parent._print_info("📦 Building and publishing freyja to PyPI...")

      # Clean and build first
      if self.clean:
        parent._clean()
      self.compile()

      # Check for PyPI token
      token_var = "TEST_PYPI_TOKEN" if test_pypi else "PYPI_TOKEN"
      if not os.environ.get(token_var):
        parent._print_error(f"{token_var} environment variable not set")
        parent._print_error(f"Please set {token_var} environment variable with your PyPI token")
        return

      parent._print_info("🔐 Configuring PyPI authentication...")

      # Configure repositories
      if test_pypi:
        repo_url = "https://test.pypi.org/legacy/"
        parent._run_command(f"poetry config repositories.testpypi {repo_url}")
        parent._run_command(f"poetry config http-basic.testpypi __token__ {os.environ[token_var]}")
        publish_cmd = "poetry publish -r testpypi"
      else:
        parent._run_command("poetry config repositories.pypi https://upload.pypi.org/legacy/")
        parent._run_command(f"poetry config http-basic.pypi __token__ {os.environ[token_var]}")
        publish_cmd = "poetry publish"

      # Publish
      if not parent._run_command(publish_cmd, "🚀 Publishing to PyPI..."):
        parent._print_error("Publishing failed!")
        return

      if test_pypi:
        parent._print_success("Published successfully to https://test.pypi.org/project/freyja/")
        parent._print_info("Install with: pip install --index-url https://test.pypi.org/simple/ freyja")
      else:
        parent._print_success("Published successfully to https://pypi.org/project/freyja/")
        parent._print_info("Install with: pip install freyja")

    def tag_version(self, version: Optional[str] = None, message: Optional[str] = None) -> None:
      """Update version in pyproject.toml and create git tag with enhanced error handling.
      :param version: Specific version (e.g., "1.0.5"). Auto-increments if not provided
      :param message: Commit message (version appended). Uses default if not provided
      """
      import re

      parent = self.parent
      parent._print_info("🏷️  Creating Freyja version tag and release...")

      # Validate git repository
      try:
        subprocess.run("git rev-parse --git-dir", shell=True, capture_output=True, text=True, check=True)
      except subprocess.CalledProcessError:
        parent._print_error("Not in a git repository")
        return

      # Determine version
      if not version:
        try:
          result = subprocess.run("git tag --sort=-version:refname", shell=True, capture_output=True, text=True, check=True)
          tags = [t for t in result.stdout.strip().split('\n') if t]

          if not tags:
            parent._print_error("No existing tags found. Please provide a version manually.")
            return

          latest_tag = tags[0]
          parent._print_info(f"Latest tag: {latest_tag}")

          version_match = re.match(r'^v?(\d+)\.(\d+)\.(\d+)$', latest_tag)
          if not version_match:
            parent._print_error(f"Invalid version format: {latest_tag} (expected X.Y.Z)")
            return

          major, minor, patch = map(int, version_match.groups())
          version = f"{major}.{minor}.{patch + 1}"
          parent._print_info(f"Auto-incrementing to: {version}")
        except subprocess.CalledProcessError:
          parent._print_error("No existing tags found. Please provide a version manually.")
          return

      version = version.lstrip('v')

      # Validate version format
      if not re.match(r'^\d+\.\d+\.\d+$', version):
        parent._print_error(f"Invalid version format: {version} (expected X.Y.Z)")
        return

      tag = f"v{version}"

      # Check if tag exists
      try:
        subprocess.run(f"git rev-parse {tag}", shell=True, capture_output=True, check=True)
        parent._print_error(f"Tag '{tag}' already exists")
        return
      except subprocess.CalledProcessError:
        pass  # Tag doesn't exist - good

      # Update version in pyproject.toml FIRST
      parent._print_info(f"📝 Updating pyproject.toml to version {version}...")
      if not parent._run_command(f"poetry version {version}", "Setting new version"):
        parent._print_error("Failed to update version in pyproject.toml")
        return
      parent._print_success(f"Updated pyproject.toml to version {version}")

      # Commit changes if any (including version update)
      result = subprocess.run("git diff-index --quiet HEAD --", shell=True, capture_output=True)
      if result.returncode != 0:
        parent._print_info("📝 Committing changes before creating tag...")

        # Generate or prepare commit message
        if not message:
          try:
            claude_result = subprocess.run(
              ["claude", "Analyze the uncommitted changes and create a concise, specific commit message (1-2 sentences max) that describes WHAT changed and WHY. Focus on user-visible changes, bug fixes, or new features. Do NOT use generic phrases like 'based on the changes' or 'here's an appropriate commit message'. Start directly with the action (e.g., 'Fix', 'Add', 'Update', 'Refactor'). Do not mention 'claude', 'git', or 'phase'."],
              capture_output=True, text=True, timeout=30
            )
            generated_message = claude_result.stdout.strip().split('\n')[0] if claude_result.returncode == 0 else ""
            message = generated_message or "Prepare release"
            parent._print_info(f"Generated message: {message}") if generated_message else None
          except (FileNotFoundError, subprocess.TimeoutExpired):
            message = "Prepare release"

        commit_message = f"{message} (v{version})"
        parent._print_info(f"Commit message: {commit_message}")

        if not parent._run_command(f'git commit -a -m "{commit_message}"', "Committing changes"):
          parent._print_error("Failed to commit changes")
          return
        parent._print_success("Changes committed successfully")
      else:
        parent._print_info("No uncommitted changes to commit")

      # Create tag
      tag_message = f"Version {version} of Freyja, the zero configuration CLI tool"
      parent._print_info(f"Creating tag: {tag}")

      if not parent._run_command(f'git tag -a "{tag}" -m "{tag_message}"', f"Creating tag {tag}"):
        parent._print_error("Failed to create tag")
        return
      parent._print_success(f"Created tag {tag}")

      # Build, lock, and install
      parent._print_info("🔨 Building package with updated version...")
      if self.clean:
        parent._clean()
      self.compile()

      if not parent._run_command("poetry lock", "Updating poetry.lock"):
        parent._print_error("Failed to update poetry.lock")
        return

      if not parent._run_command("poetry install", "Installing updated package"):
        parent._print_error("Failed to install updated package")
        return

      parent._run_command("poetry version", "📋 Current Poetry version:")

      # Enhanced git push with specific error detection
      parent._print_info("🚀 Pushing commit and tag to remote...")
      push_result = subprocess.run("git push --follow-tags", shell=True, capture_output=True, text=True, cwd=parent.project_root)

      if push_result.returncode != 0:
        stderr = push_result.stderr.lower()
        stdout = push_result.stdout.lower()
        output = stderr + stdout

        # Parse specific git push errors and provide actionable guidance
        if "has no upstream branch" in output or "no upstream" in output:
          branch_result = subprocess.run("git branch --show-current", shell=True, capture_output=True, text=True)
          branch_name = branch_result.stdout.strip()
          parent._print_error(f"Current branch '{branch_name}' has no upstream remote")
          parent._print_info(f"Run: {parent.colors['blue']}git push --set-upstream origin {branch_name} --follow-tags{parent.colors['nc']}")
        elif "authentication" in output or "permission denied" in output or "403" in output:
          parent._print_error("Authentication failed. Check your GitHub credentials or SSH keys")
          parent._print_info("For SSH: Ensure your SSH key is added to GitHub")
          parent._print_info("For HTTPS: Check your personal access token")
        elif "could not resolve host" in output or "unable to access" in output:
          parent._print_error("Network error: Unable to connect to remote repository")
          parent._print_info("Check your internet connection and try again")
        elif "rejected" in output or "pre-receive hook" in output:
          parent._print_error("Remote rejected the push (possibly due to branch protection rules)")
          parent._print_info("Check repository settings or contact repository admin")
        elif "non-fast-forward" in output:
          parent._print_error("Remote contains work not present locally")
          parent._print_info(f"Run: {parent.colors['blue']}git pull --rebase origin && git push --follow-tags{parent.colors['nc']}")
        else:
          # Generic error with full output for debugging
          parent._print_error("Failed to push to remote. Tag and commit created locally.")
          parent._print_info(f"Error details: {push_result.stderr[:200] if push_result.stderr else push_result.stdout[:200]}")
          parent._print_info(f"To push manually: {parent.colors['blue']}git push --follow-tags{parent.colors['nc']}")
        return

      # Success summary
      parent._print_success("🎉 Release complete!")
      parent._print_success(f"Tagged version: {tag}")
      parent._print_success(f"Updated pyproject.toml to version {version}")
      parent._print_success("Package built successfully")
      parent._print_success("Pushed to remote repository")
      parent._print_info(f"Check release: {parent.colors['blue']}https://github.com/terracoil/freyja/releases{parent.colors['nc']}")

  class Test:
    """Testing, diagnostics, and quality assurance operations."""

    def __init__(self, parent, clean: bool = False, coverage: bool = True):
      """
      Initialize test operations.

      :param parent: Parent FreyjaDevTools instance
      :param clean: Clean build artifacts before operations
      :param coverage: Enable coverage reporting by default
      """
      self.parent = parent
      self.clean = clean
      self.coverage = coverage

    def run(self, pattern: str = "", parallel: bool = False, verbose_output: bool = False) -> None:
      """
      Run the test suite with coverage reporting.

      :param pattern: Pattern to filter tests (e.g., "test_cli")
      :param parallel: Run tests in parallel (requires pytest-xdist)
      :param verbose_output: Enable verbose test output
      """
      parent = self.parent

      if self.clean:
        parent._clean()

      parent._print_info("🧪 Running tests with coverage...")

      # Build test command
      cmd_parts = ["poetry run pytest"]

      if self.coverage:
        cmd_parts.extend(["--cov=freyja", "--cov-report=term-missing", "--cov-report=html"])

      if verbose_output:
        cmd_parts.append("-v")

      if parallel:
        cmd_parts.append("-n auto")

      if pattern:
        cmd_parts.append(f"-k {pattern}")

      test_command = " ".join(cmd_parts)

      if not parent._run_command(test_command):
        parent._print_error("Tests failed!")
        return

      parent._print_info("📊 Coverage report generated in htmlcov/")
      parent._print_success("Tests completed successfully!")

    def completion(self, examples_only: bool = False) -> None:
      """
      Test shell completion functionality comprehensively.

      :param examples_only: Only test example completion, not full suite
      """
      parent = self.parent

      if self.clean:
        parent._clean()

      parent._print_info("🔧 Testing shell completion functionality...")

      # Set up environment
      os.environ['PYTHONPATH'] = str(parent.project_root)
      os.chdir(parent.project_root)

      tests_passed = 0
      tests_failed = 0
      critical_failures = 0

      def run_completion_test(test_name: str, test_command: str, expected_pattern: str, critical: bool = False) -> bool:
        nonlocal tests_passed, tests_failed, critical_failures

        if parent.verbose:
          print(f"Running test: {test_name}")
          print(f"Command: {test_command}")

        try:
          result = subprocess.run(test_command, shell=True, capture_output=True, text=True, timeout=10)

          if expected_pattern in result.stdout or expected_pattern in result.stderr:
            if parent.verbose:
              parent._print_success(f"✅ {test_name}")
            tests_passed += 1
            return True
          else:
            parent._print_error(f"❌ {test_name}")
            if parent.verbose:
              print(f"Expected pattern: {expected_pattern}")
              print(f"Stdout: {result.stdout[:200]}")
              print(f"Stderr: {result.stderr[:200]}")
            tests_failed += 1
            if critical:
              critical_failures += 1
            return False

        except subprocess.TimeoutExpired:
          parent._print_error(f"⏰ {test_name} - TIMEOUT")
          tests_failed += 1
          if critical:
            critical_failures += 1
          return False
        except Exception as e:
          parent._print_error(f"💥 {test_name} - ERROR: {e}")
          tests_failed += 1
          if critical:
            critical_failures += 1
          return False

      # Test basic completion functionality
      if not examples_only:
        parent._print_info("Testing basic completion system...")

        # Test help completion
        run_completion_test(
          "Help completion",
          "python examples/cls_example --help",
          "usage:",
          critical=True
        )

        # Test command completion
        run_completion_test(
          "Command completion",
          "python examples/cls_example completion install",
          "completion",
          critical=False
        )

      # Test examples completion
      parent._print_info("Testing examples completion...")

      # Test cls_example basic functionality
      run_completion_test(
        "cls_example help",
        "python examples/cls_example --help",
        "usage:",
        critical=True
      )

      # Test cls_example command execution
      run_completion_test(
        "cls_example command execution",
        "python examples/cls_example file-operations--process-single --input-file test.txt --dry-run",
        "test.txt",
        critical=False
      )

      # Test multi-class example
      run_completion_test(
        "multi_class_example help",
        "python examples/multi_class_example --help",
        "usage:",
        critical=False
      )

      # Print results
      total_tests = tests_passed + tests_failed
      parent._print_info(f"Completion test results: {tests_passed}/{total_tests} passed")

      if critical_failures > 0:
        parent._print_error(f"❌ {critical_failures} critical failures detected!")
        return

      if tests_failed > 0:
        parent._print_error(f"⚠️  {tests_failed} non-critical tests failed")
      else:
        parent._print_success("All completion tests passed!")

    def diagnose(self, include_env: bool = True, include_completion: bool = True) -> None:
      """
      Comprehensive diagnostic analysis for development issues.

      :param include_env: Include environment variable analysis
      :param include_completion: Include completion system analysis
      """
      parent = self.parent

      if self.clean:
        parent._clean()

      parent._print_info("🔍 Running comprehensive diagnostic analysis...")

      if include_env:
        parent._print_info("=== Environment Variable Analysis ===")
        print(f"Current shell: {os.environ.get('SHELL', 'Unknown')}")
        print(f"Current PID: {os.getpid()}")
        print()

        # Check Freyja-related environment variables
        freyja_vars = {k: v for k, v in os.environ.items() if 'freyja' in k.lower() or 'comp_' in k.lower()}
        if freyja_vars:
          print("Freyja completion environment variables:")
          for k, v in freyja_vars.items():
            print(f"  {k}={v}")
        else:
          print("No Freyja completion environment variables found")
        print()

      if include_completion:
        parent._print_info("=== Completion System Analysis ===")

        # Test completion system availability
        try:
          result = subprocess.run("python examples/cls_example completion --help",
                                  shell=True, capture_output=True, text=True, timeout=5)
          if result.returncode == 0:
            parent._print_success("Completion system is available")
          else:
            parent._print_error("Completion system unavailable or broken")
        except Exception as e:
          parent._print_error(f"Failed to test completion system: {e}")

        # Test shell-specific completion
        shell = os.environ.get('SHELL', '')
        if 'bash' in shell:
          parent._run_command("complete -p | grep -i freyja || echo 'No bash completion found'", "Bash completion status:")
        elif 'zsh' in shell:
          parent._run_command("compdef | grep -i freyja || echo 'No zsh completion found'", "Zsh completion status:")

        print()

      # Python environment check
      parent._print_info("=== Python Environment ===")
      parent._run_command("poetry run python --version", "Python version:")
      parent._run_command("poetry run python -c 'import freyja; print(f\"Freyja module: {freyja.__file__}\")'", "Freyja module location:")

      # Project structure check
      parent._print_info("=== Project Structure ===")
      important_files = [
        "pyproject.toml",
        "freyja/__init__.py",
        "examples/cls_example",
        "examples/multi_class_example"
      ]

      for file_path in important_files:
        full_path = parent.project_root / file_path
        if full_path.exists():
          parent._print_success(f"✅ {file_path} exists")
        else:
          parent._print_error(f"❌ {file_path} missing")

      parent._print_success("Diagnostic analysis complete!")


if __name__ == '__main__':
  # Create the CLI instance and store reference for inner classes
  dev_tools = FreyjaDevTools()
  sys.modules[__name__].__dict__['_parent_instance'] = dev_tools

  cli = FreyjaCLI(FreyjaDevTools, title="Freyja Development Tools")
  result = cli.run()
  sys.exit(result if isinstance(result, int) else 0)
